(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{125:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return d}));var a=n(1),i=n(6),o=(n(0),n(149)),r={title:"10. Automatic normalisation",description:"10th part of the tutorial for redux-requests - declarative AJAX requests and automatic network state management for Redux"},l={id:"tutorial/10-automatic-normalisation",title:"10. Automatic normalisation",description:"10th part of the tutorial for redux-requests - declarative AJAX requests and automatic network state management for Redux",source:"@site/docs/tutorial/10-automatic-normalisation.md",permalink:"/docs/tutorial/10-automatic-normalisation",editUrl:"https://github.com/klis87/redux-requests/edit/master/docusaurus/docs/tutorial/10-automatic-normalisation.md",lastUpdatedBy:"klis87",lastUpdatedAt:1595253322,sidebar:"docs",previous:{title:"9. Caching",permalink:"/docs/tutorial/9-caching"},next:{title:"Using drivers",permalink:"/docs/drivers/using-drivers"}},s=[{value:"What is normalisation?",id:"what-is-normalisation",children:[]},{value:"How does it work?",id:"how-does-it-work",children:[]},{value:"Required conditions",id:"required-conditions",children:[]},{value:"Normalisation of arrays",id:"normalisation-of-arrays",children:[]},{value:"Normalisation and local/optimistic updates",id:"normalisation-and-localoptimistic-updates",children:[]}],c={rightToc:s};function d(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"what-is-normalisation"},"What is normalisation?"),Object(o.b)("p",null,"Normalisation is a process of keeping data in such a way that no information is duplicated.\nSo for instance if you have a book with id ",Object(o.b)("inlineCode",{parentName:"p"},"1")," in multiple queries, it should be stored only in\none place anyway. This way state is better organized plus updates are easy - book has to be updated\nonly in one place no matter in how many queries it is present."),Object(o.b)("p",null,"Typically ",Object(o.b)("inlineCode",{parentName:"p"},"normalizr")," is used in Redux world to normalize data, it has big disadvantage though, namely\nyou need to do everything manually. However. this library suggests 100% automatic approach, which you might\nalready see in GraphQL world like in Apollo library."),Object(o.b)("p",null,"This library does similar thing, but not only for GraphQL, but for anything, including REST!"),Object(o.b)("h2",{id:"how-does-it-work"},"How does it work?"),Object(o.b)("p",null,"By default nothing is normalized. You can pass ",Object(o.b)("inlineCode",{parentName:"p"},"normalize: true")," to ",Object(o.b)("inlineCode",{parentName:"p"},"handleRequests"),"\nto normalize everything, or you can use request action ",Object(o.b)("inlineCode",{parentName:"p"},"meta.normalize: true")," to activate it\nper request type."),Object(o.b)("p",null,"Now, lets say you have two queries:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const fetchBooks = () => ({\n  type: FETCH_BOOKS,\n  request: { url: '/books' },\n  meta: { normalize: true },\n});\n\nconst fetchBook = id => ({\n  type: FETCH_BOOK,\n  request: { url: `/books/${id}` },\n  meta: { normalize: true },\n})\n")),Object(o.b)("p",null,"and ",Object(o.b)("inlineCode",{parentName:"p"},"getQuery")," returns the following data:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"import { getQuery } from '@redux-requests/core';\n\nconst booksQuery = getQuery(state, { type: 'FETCH_BOOKS' });\n// booksQuery.data is [{ id: '1', title: 'title 1'}, { id: '2', title: 'title 2'}]\n\nconst bookDetailQuery = getQuery(state, { type: 'FETCH_BOOK' });\n// bookDetailQuery.data is { id: '1', title: 'title 1'}\n")),Object(o.b)("p",null,"Now, imagine you have a mutation to update a book title. Normally you would need to do\nsomething like that:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const updateBookTitle = (id, newTitle) => ({\n  type: UPDATE_BOOK_TITLE,\n  request: { url: `books/${id}`, method: 'PATCH', data: { newTitle } },\n  meta: {\n    mutations: {\n      FETCH_BOOKS: (data, mutationData) => data.map(v => v.id === id ? mutationData : v),\n      FETCH_BOOK: (data, mutationData) => data.id === id ? mutationData : data,\n    },\n  },\n})\n")),Object(o.b)("p",null,"assuming ",Object(o.b)("inlineCode",{parentName:"p"},"mutationData")," is equal to the book with updated title."),Object(o.b)("p",null,"Now, because we have queries normalized, we can also use normalization in mutation:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const updateBookTitle = (id, newTitle) => ({\n  type: 'UPDATE_BOOK_TITLE',\n  request: { url: `books/${id}`, method: 'PATCH', data: { newTitle } },\n  meta: { normalize: true },\n})\n")),Object(o.b)("p",null,"No manual mutations! How does it work? By default all objects with ",Object(o.b)("inlineCode",{parentName:"p"},"id")," key are\norganized by their ids. Now, if you use ",Object(o.b)("inlineCode",{parentName:"p"},"normalize: true"),", any object with key ",Object(o.b)("inlineCode",{parentName:"p"},"id"),"\nwill be normalized, which simply means stored by id. If there is already a matching object\nwith the same id, new one will be deeply merged with the one already in state.\nSo, if only server response data from ",Object(o.b)("inlineCode",{parentName:"p"},"UPDATE_BOOK_TITLE")," is ",Object(o.b)("inlineCode",{parentName:"p"},"{ id: '1', title: 'new title' }"),",\nthis library will automatically figure it out to update ",Object(o.b)("inlineCode",{parentName:"p"},"title")," for object with ",Object(o.b)("inlineCode",{parentName:"p"},"id: '1'"),"."),Object(o.b)("p",null,"It also works with nested objects with ids, no matter how deep. If an object with id has other objects\nwith ids, then those will be normalized separately and parent object will have just reference to those nested\nobjects."),Object(o.b)("h2",{id:"required-conditions"},"Required conditions"),Object(o.b)("p",null,"In order to make automatic normalisation work, the following conditions must be meet:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"you must have a standardized way to identify your objects, usually this is just ",Object(o.b)("inlineCode",{parentName:"li"},"id")," key"),Object(o.b)("li",{parentName:"ol"},"ids must be unique across the whole app, not only across object types, if not, you will need to append something to them,\nthe same has to be done in GraphQL world, usually adding ",Object(o.b)("inlineCode",{parentName:"li"},"_typename")),Object(o.b)("li",{parentName:"ol"},"objects with the same ids should have consistent structure, if an object like book in one\nquery has ",Object(o.b)("inlineCode",{parentName:"li"},"title")," key, it should be ",Object(o.b)("inlineCode",{parentName:"li"},"title")," in others, not ",Object(o.b)("inlineCode",{parentName:"li"},"name")," out of a sudden")),Object(o.b)("p",null,"Two functions which can be passed to ",Object(o.b)("inlineCode",{parentName:"p"},"handleRequest")," can help to meet those requirements,\n",Object(o.b)("inlineCode",{parentName:"p"},"shouldObjectBeNormalized")," and ",Object(o.b)("inlineCode",{parentName:"p"},"getNormalisationObjectKey"),"."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"shouldObjectBeNormalized")," can help you with 1st point, if for instance you identify\nobjects differently, for instance by ",Object(o.b)("inlineCode",{parentName:"p"},"_id")," key, then you can pass\n",Object(o.b)("inlineCode",{parentName:"p"},"shouldObjectBeNormalized: obj => obj._id !== undefined")," to ",Object(o.b)("inlineCode",{parentName:"p"},"handleRequest"),"."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"getNormalisationObjectKey")," allows you to pass 2nd requirement. For example, if your ids\nare unique, but not across the whole app, but within object types, you could use\n",Object(o.b)("inlineCode",{parentName:"p"},"getNormalisationObjectKey: obj => obj.id + obj.type")," or something similar.\nIf that is not possible, then you could just compute a suffix yourself, for example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const getType = obj => {\n  if (obj.bookTitle) {\n    return 'book';\n  }\n\n  if (obj.surname) {\n    return 'user';\n  }\n\n  throw 'we support only book and user object';\n}\n\n{\n  getNormalisationObjectKey: obj => obj.id + getType(obj),\n}\n")),Object(o.b)("p",null,"Point 3 should always be met, if not, your really should ask your backend developers\nto keep things standardized and consistent. As a last resort, you can amend response with\n",Object(o.b)("inlineCode",{parentName:"p"},"meta.getData"),"."),Object(o.b)("h2",{id:"normalisation-of-arrays"},"Normalisation of arrays"),Object(o.b)("p",null,"Unfortunately it does not mean you will never use ",Object(o.b)("inlineCode",{parentName:"p"},"meta.mutations"),". Some updates still need\nto be done manually like usually, namely adding and removing items from array. Why? Imagine ",Object(o.b)("inlineCode",{parentName:"p"},"REMOVE_BOOK"),"\nmutation. This book could be present in many queries, library cannot know from which query\nyou would like to remove it. The same applies for ",Object(o.b)("inlineCode",{parentName:"p"},"ADD_BOOK"),", library cannot know to which query a book should be added,\nor even as which array index. The same thing for action like ",Object(o.b)("inlineCode",{parentName:"p"},"SORT_BOOKS"),". This problem affects only top\nlevel arrays though. For instance, if you have a book with some id and another key like ",Object(o.b)("inlineCode",{parentName:"p"},"likedByUsers"),",\nthen if you return new book with updated list in ",Object(o.b)("inlineCode",{parentName:"p"},"likedByUsers"),", this will work again automatically."),Object(o.b)("h2",{id:"normalisation-and-localoptimistic-updates"},"Normalisation and local/optimistic updates"),Object(o.b)("p",null,"Automatic normalisation is compatible with local and optimistic updates. There are\n3 action meta options dedicated to normalized data:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"optimisticData"),": cousin of meta.mutation ",Object(o.b)("inlineCode",{parentName:"li"},"updateDataOptimistic"),","),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"revertedData"),": cousin of meta.mutation ",Object(o.b)("inlineCode",{parentName:"li"},"revertData")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"localData"),": cousing of meta.mutation ",Object(o.b)("inlineCode",{parentName:"li"},"updateData")," with ",Object(o.b)("inlineCode",{parentName:"li"},"local: true"))),Object(o.b)("p",null,"Just attached an object or objects with ids there to update data, for example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const likeBooks = ids => ({\n  type: 'LIKE_BOOKS',\n  meta: {\n    localData: ids.map(id => ({ id, liked: true })),\n  },\n})\n")),Object(o.b)("p",null,"Dispatching above action like ",Object(o.b)("inlineCode",{parentName:"p"},"store.dispatch(likeBooks(['1', '2', '3']))")," would\nmark books with ids ",Object(o.b)("inlineCode",{parentName:"p"},"1"),", ",Object(o.b)("inlineCode",{parentName:"p"},"2")," and ",Object(o.b)("inlineCode",{parentName:"p"},"3")," as liked."),Object(o.b)("p",null,"With optimistic updates usage is similar, for instance:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const likeBookOptimistic = id => ({\n  type: 'LIKE_BOOK_OPTIMISTIC',\n  meta: {\n    optimisticData: { id, liked: true },\n    revertedData: { id, liked: false },\n  },\n})\n")))}d.isMDXComponent=!0},149:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return m}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),d=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},u=function(e){var t=d(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},p=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(n),p=a,m=u["".concat(r,".").concat(p)]||u[p]||b[p]||o;return n?i.a.createElement(m,l({ref:t},c,{components:n})):i.a.createElement(m,l({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);