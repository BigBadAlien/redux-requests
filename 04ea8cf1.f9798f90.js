(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{163:function(e,r,n){"use strict";n.d(r,"a",(function(){return p})),n.d(r,"b",(function(){return m}));var t=n(0),o=n.n(t);function a(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function s(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function i(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?s(Object(n),!0).forEach((function(r){a(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function c(e,r){if(null==e)return{};var n,t,o=function(e,r){if(null==e)return{};var n,t,o={},a=Object.keys(e);for(t=0;t<a.length;t++)n=a[t],r.indexOf(n)>=0||(o[n]=e[n]);return o}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)n=a[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),d=function(e){var r=o.a.useContext(l),n=r;return e&&(n="function"==typeof e?e(r):i({},r,{},e)),n},p=function(e){var r=d(e.components);return o.a.createElement(l.Provider,{value:r},e.children)},u={inlineCode:"code",wrapper:function(e){var r=e.children;return o.a.createElement(o.a.Fragment,{},r)}},b=Object(t.forwardRef)((function(e,r){var n=e.components,t=e.mdxType,a=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=d(n),b=t,m=p["".concat(s,".").concat(b)]||p[b]||u[b]||a;return n?o.a.createElement(m,i({ref:r},l,{components:n})):o.a.createElement(m,i({ref:r},l))}));function m(e,r){var n=arguments,t=r&&r.mdxType;if("string"==typeof e||t){var a=n.length,s=new Array(a);s[0]=b;var i={};for(var c in r)hasOwnProperty.call(r,c)&&(i[c]=r[c]);i.originalType=e,i.mdxType="string"==typeof e?e:t,s[1]=i;for(var l=2;l<a;l++)s[l]=n[l];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},99:function(e,r,n){"use strict";n.r(r),n.d(r,"frontMatter",(function(){return s})),n.d(r,"metadata",(function(){return i})),n.d(r,"rightToc",(function(){return c})),n.d(r,"default",(function(){return d}));var t=n(1),o=n(6),a=(n(0),n(163)),s={title:"Using drivers",description:"Using drivers guide for redux-requests - declarative AJAX requests and automatic network state management for single-page applications"},i={id:"drivers/using-drivers",title:"Using drivers",description:"Using drivers guide for redux-requests - declarative AJAX requests and automatic network state management for single-page applications",source:"@site/docs/drivers/using-drivers.md",permalink:"/docs/drivers/using-drivers",editUrl:"https://github.com/klis87/redux-requests/edit/master/docusaurus/docs/drivers/using-drivers.md",lastUpdatedBy:"Konrad",lastUpdatedAt:1610499904,sidebar:"docs",previous:{title:"10. Automatic normalisation",permalink:"/docs/tutorial/10-automatic-normalisation"},next:{title:"Axios driver",permalink:"/docs/drivers/axios-driver"}},c=[{value:"What is driver?",id:"what-is-driver",children:[]},{value:"How to use drivers",id:"how-to-use-drivers",children:[]},{value:"Multiple drivers",id:"multiple-drivers",children:[]},{value:"Writing your own driver",id:"writing-your-own-driver",children:[]},{value:"Supporting more than just data",id:"supporting-more-than-just-data",children:[]},{value:"Supporting aborts in custom drivers",id:"supporting-aborts-in-custom-drivers",children:[]},{value:"Making your driver configurable",id:"making-your-driver-configurable",children:[]},{value:"Supporting download and upload progress",id:"supporting-download-and-upload-progress",children:[]}],l={rightToc:c};function d(e){var r=e.components,n=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(t.a)({},l,n,{components:r,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"what-is-driver"},"What is driver?"),Object(a.b)("p",null,"You must have noticed by now that this library uses a concept called ",Object(a.b)("strong",{parentName:"p"},"drivers"),".\nSo what is driver exactly? Technically, driver is just a function, which receives a request config,\nsends an AJAX request and returns a promise, which will be resolved for success case and\nrejected for error or abort cases. Practically, driver is an abstraction, a way to use this library\nwith any way to communicate with servers. Some people like Axios, other Fetch API. Some people like\nREST, other prefer GraphQL. Thanks to drivers concept you can use anything, even in combination in one app -\nthat's it, it is possible to use multiple drivers at the same time! Anyway, this library\nprovides many built-in drivers, but it is also possible to write your own, which\nwill be covered later in this chapter."),Object(a.b)("h2",{id:"how-to-use-drivers"},"How to use drivers"),Object(a.b)("p",null,"You must use at least one driver. You can choose one of provided drivers by this library\nor write your own. Let's assume we pick ",Object(a.b)("inlineCode",{parentName:"p"},"fetch")," driver. Install it:"),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-bash"}),"$ npm install @redux-requests/fetch\n")),Object(a.b)("p",null,"and pass it to ",Object(a.b)("inlineCode",{parentName:"p"},"handleRequests"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-js"}),"import 'isomorphic-fetch';\nimport { handleRequests } from '@redux-requests/core';\nimport { createDriver } from '@redux-requests/fetch';\n\nhandleRequests({\n  driver: createDriver(window.fetch, {\n    baseURL: 'https://my-domain.com',\n    AbortController: window.AbortController,\n  }),\n});\n")),Object(a.b)("p",null,"And that's it, ",Object(a.b)("inlineCode",{parentName:"p"},"fetch")," driver is ready to use and the library will understand\n",Object(a.b)("inlineCode",{parentName:"p"},"Fetch API")," config in request actions."),Object(a.b)("h2",{id:"multiple-drivers"},"Multiple drivers"),Object(a.b)("p",null,"You can use multiple drivers at the same time if you need it. For example, if you want to use Axios by default, but also Fetch API\nsometimes, you can do it like this:"),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-js"}),"import axios from 'axios';\nimport 'isomorphic-fetch';\nimport { handleRequests } from '@redux-requests/core';\nimport { createDriver as createAxiosDriver } from '@redux-requests/axios';\nimport { createDriver as createFetchDriver } from '@redux-requests/fetch';\n\nhandleRequests({\n  driver: {\n    default: createAxiosDriver(axios),\n    fetch: createFetchDriver(window.fetch, {\n      baseURL: 'https://my-domain.com',\n      AbortController: window.AbortController,\n    }),\n  },\n});\n")),Object(a.b)("p",null,"As you can see, the default driver is Axios, so how to mark a request to be run by Fetch driver?\nJust pass the key you assigned Fetch driver to (",Object(a.b)("inlineCode",{parentName:"p"},"fetch")," in our case) in ",Object(a.b)("inlineCode",{parentName:"p"},"action.meta.driver"),", for instance:"),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-js"}),"const fetchUsers = () => ({\n  type: 'FETCH_USERS',\n  request: {\n    url: '/users/',\n    method: 'POST',\n    body: JSON.stringify(data),\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  },\n  meta: {\n    driver: 'fetch',\n  },\n});\n")),Object(a.b)("h2",{id:"writing-your-own-driver"},"Writing your own driver"),Object(a.b)("p",null,"As mentioned earlier, driver is just a function, which receives a request config,\nsends an AJAX request and returns a promise, which will be resolved for success case and rejected for error or abort cases."),Object(a.b)("p",null,"So, let's write ",Object(a.b)("inlineCode",{parentName:"p"},"axios")," driver. In order to understand what will happen next, it is recommended\nto get familiar with ",Object(a.b)("inlineCode",{parentName:"p"},"axios")," library, especially how to abort requests. Anyway, let's start some coding:"),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-js"}),"import axios from 'axios';\n\nconst axiosDriver = requestConfig => {\n  return axios(requestConfig).then(response => ({ data: response.data }));\n};\n")),Object(a.b)("p",null,"Well, it wasn't so difficult, was it? As we can see, we just wrote a function\nwhich get's ",Object(a.b)("inlineCode",{parentName:"p"},"requestConfig")," (it will be passed from ",Object(a.b)("inlineCode",{parentName:"p"},"action.request"),") and returns\ncalled ",Object(a.b)("inlineCode",{parentName:"p"},"axios")," with it. ",Object(a.b)("inlineCode",{parentName:"p"},"axios(requestConfig)")," already returns a promise which will\nbe rejected for error, so we are good here. The only thing we did is adding\n",Object(a.b)("inlineCode",{parentName:"p"},".then(response => ({ data: response.data }))")," to resolve promises only with ",Object(a.b)("inlineCode",{parentName:"p"},"data")," -\nthe library expects promises to be resolved with object with at least ",Object(a.b)("inlineCode",{parentName:"p"},"data"),"."),Object(a.b)("h2",{id:"supporting-more-than-just-data"},"Supporting more than just data"),Object(a.b)("p",null,"As written above, for success response promise has to be resolved with an object\nwith at least ",Object(a.b)("inlineCode",{parentName:"p"},"data")," key, but you can add anything else:"),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-js"}),"import axios from 'axios';\n\nconst axiosDriver = requestConfig => {\n  return axios(requestConfig).then(response => ({\n    data: response.data,\n    headers: response.headers,\n    status: response.status,\n  }));\n};\n")),Object(a.b)("p",null,"Now ",Object(a.b)("inlineCode",{parentName:"p"},"headers")," and ",Object(a.b)("inlineCode",{parentName:"p"},"status")," will be available in ",Object(a.b)("inlineCode",{parentName:"p"},"onSuccess")," interceptor and in\npromise which is returned by request action dispatch (next to ",Object(a.b)("inlineCode",{parentName:"p"},"data"),"). However,\nnote that still only ",Object(a.b)("inlineCode",{parentName:"p"},"data")," will be stored in reducer, so if you need to access a header\nfor instance from Redux state, you can store it in your own reducer or you could merge\na header with ",Object(a.b)("inlineCode",{parentName:"p"},"data")," inside ",Object(a.b)("inlineCode",{parentName:"p"},"onSuccess")," interceptor."),Object(a.b)("h2",{id:"supporting-aborts-in-custom-drivers"},"Supporting aborts in custom drivers"),Object(a.b)("p",null,"We are not done yet though, our driver does not support aborts yet, let's fix that:"),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-js"}),"import axios from 'axios';\n\nconst axiosDriver = requestConfig => {\n  const abortSource = axios.CancelToken.source();\n\n  const responsePromise = axios({\n    cancelToken: abortSource.token,\n    ...requestConfig,\n  })\n    .then(response => ({\n      data: response.data,\n      headers: response.headers,\n      status: response.status,\n    }))\n    .catch(error => {\n      if (axios.isCancel(error)) {\n        throw 'REQUEST_ABORTED';\n      }\n\n      throw error;\n    });\n\n  responsePromise.cancel = () => abortSource.cancel();\n  return responsePromise;\n};\n")),Object(a.b)("p",null,"This looks a little more complicated, but it is not, let's analyze above code steps\nby steps. First of all, to support abort we decorated returned promise with ",Object(a.b)("inlineCode",{parentName:"p"},"cancel"),"\nmethod, which will be called by the library when a request should be aborted. Native\npromises cannot be aborted/cancelled, but by adding this we make it possible. This technique\nis quite similar for example to ",Object(a.b)("inlineCode",{parentName:"p"},"Bluebird")," promises. Moreover, notice ",Object(a.b)("inlineCode",{parentName:"p"},"catch")," logic.\nThis uses ",Object(a.b)("inlineCode",{parentName:"p"},"axios")," helper to check whether request promise was rejected due to abort\nor another error, and in case of abort, we throw special error ",Object(a.b)("inlineCode",{parentName:"p"},"REQUEST_ABORTED"),", so that\nthe library can know that promise was rejected due to cancellation. This is needed because\nwe need to handle 3 response types - success, error or abort, while promise can be just\nresolved or rejected. We could also use observables instead of promises as building blocks\nfor drivers, but they are less popular than promises and they require libraries/polyfills installed.\nHence the decision for such API. Also, you need to remember not to use async function!\nIf you do, javascript engine would wrap your returned promise and ",Object(a.b)("inlineCode",{parentName:"p"},".cancel")," method would be gone!\nSo resist the temptation and stick just to promises when writing drivers!"),Object(a.b)("h2",{id:"making-your-driver-configurable"},"Making your driver configurable"),Object(a.b)("p",null,"Most of the time you would probably want your driver to be configurable. For instance,\nwe might want to allow to pass a custom ",Object(a.b)("inlineCode",{parentName:"p"},"axios")," instance to ",Object(a.b)("inlineCode",{parentName:"p"},"axios")," driver. So let's refactor what we have:"),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-js"}),"import axios from 'axios';\n\nconst createAxiosDriver = axiosInstance => requestConfig => {\n  const abortSource = axios.CancelToken.source();\n\n  const responsePromise = axiosInstance({\n    cancelToken: abortSource.token,\n    ...requestConfig,\n  })\n    .then(response => ({\n      data: response.data,\n      headers: response.headers,\n      status: response.status,\n    }))\n    .catch(error => {\n      if (axios.isCancel(error)) {\n        throw 'REQUEST_ABORTED';\n      }\n\n      throw error;\n    });\n\n  responsePromise.cancel = () => abortSource.cancel();\n  return responsePromise;\n};\n")),Object(a.b)("p",null,"Now we could create driver with a configured axios, like:"),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-js"}),"import axios from 'axios';\n\nconst axiosDriver = createAxiosDriver(\n  axios.create({\n    baseURL: 'https://some-domain.com/api/',\n  }),\n);\n")),Object(a.b)("p",null,"So basically we refactored ",Object(a.b)("inlineCode",{parentName:"p"},"axiosDriver")," into ",Object(a.b)("inlineCode",{parentName:"p"},"createAxiosDriver")," - function which\nreturns ",Object(a.b)("inlineCode",{parentName:"p"},"axiosDriver"),". This technique is of course not mandatory but it might be handy\nto make your drivers more flexible."),Object(a.b)("h2",{id:"supporting-download-and-upload-progress"},"Supporting download and upload progress"),Object(a.b)("p",null,"Optionally drivers could support download and upload progress. Because ",Object(a.b)("inlineCode",{parentName:"p"},"axios")," makes it easy with the help of\n",Object(a.b)("a",Object(t.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent"}),"ProgressEvent"),", let's see how we could implement it:"),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-js"}),"import axios from 'axios';\n\nconst calculateProgress = progressEvent =>\n  parseInt((progressEvent.loaded / progressEvent.total) * 100);\n\nconst createAxiosDriver = axiosInstance => (\n  requestConfig,\n  requestAction,\n  driverActions,\n) => {\n  const abortSource = axios.CancelToken.source();\n\n  const responsePromise = axiosInstance({\n    cancelToken: abortSource.token,\n    onDownloadProgress:\n      driverActions.setDownloadProgress &&\n      (progressEvent => {\n        if (progressEvent.lengthComputable) {\n          driverActions.setDownloadProgress(calculateProgress(progressEvent));\n        }\n      }),\n    onUploadProgress:\n      driverActions.setUploadProgress &&\n      (progressEvent => {\n        if (progressEvent.lengthComputable) {\n          driverActions.setUploadProgress(calculateProgress(progressEvent));\n        }\n      }),\n    ...requestConfig,\n  })\n    .then(response => ({\n      data: response.data,\n      headers: response.headers,\n      status: response.status,\n    }))\n    .catch(error => {\n      if (axios.isCancel(error)) {\n        throw 'REQUEST_ABORTED';\n      }\n\n      throw error;\n    });\n\n  responsePromise.cancel = () => abortSource.cancel();\n  return responsePromise;\n};\n")),Object(a.b)("p",null,"As you can see, you could utilise ",Object(a.b)("inlineCode",{parentName:"p"},"driverActions")," helpers which are passed to any driver. We use them in\n",Object(a.b)("inlineCode",{parentName:"p"},"axios")," ",Object(a.b)("inlineCode",{parentName:"p"},"onDownloadProgress")," and ",Object(a.b)("inlineCode",{parentName:"p"},"onUploadProgress")," callbacks. After adding this, you could add ",Object(a.b)("inlineCode",{parentName:"p"},"meta.measureDownloadProgress"),"\nor ",Object(a.b)("inlineCode",{parentName:"p"},"meta.measureUploadProgress")," to a request action and you could access ",Object(a.b)("inlineCode",{parentName:"p"},"downloadProgress")," or ",Object(a.b)("inlineCode",{parentName:"p"},"uploadProgress")," values from selectors like ",Object(a.b)("inlineCode",{parentName:"p"},"getQuery")," or ",Object(a.b)("inlineCode",{parentName:"p"},"getMutation"),"."))}d.isMDXComponent=!0}}]);