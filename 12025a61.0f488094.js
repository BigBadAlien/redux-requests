(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{101:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return l}));var a=n(1),r=n(6),o=(n(0),n(149)),i={title:"3. Request keys",description:"3rd part of the tutorial for redux-requests - declarative AJAX requests and automatic network state management for Redux"},s={id:"tutorial/3-request-keys",title:"3. Request keys",description:"3rd part of the tutorial for redux-requests - declarative AJAX requests and automatic network state management for Redux",source:"@site/docs/tutorial/3-request-keys.md",permalink:"/docs/tutorial/3-request-keys",editUrl:"https://github.com/klis87/redux-requests/edit/master/docusaurus/docs/tutorial/3-request-keys.md",lastUpdatedBy:"klis87",lastUpdatedAt:1595116360,sidebar:"docs",previous:{title:"2. Batch requests",permalink:"/docs/tutorial/2-batch-requests"},next:{title:"4. Reacting to request actions",permalink:"/docs/tutorial/4-reacting-to-request-actions"}},c=[{value:"Sending requests with <code>requestKey</code>",id:"sending-requests-with-requestkey",children:[]},{value:"Selectors with <code>requestKey</code>",id:"selectors-with-requestkey",children:[]},{value:"Updating data of queries with <code>requestKey</code>",id:"updating-data-of-queries-with-requestkey",children:[]},{value:"Mutations with <code>requestKey</code>",id:"mutations-with-requestkey",children:[]},{value:"<code>abortActions</code> and <code>resetActions</code> with <code>requestKey</code>",id:"abortactions-and-resetactions-with-requestkey",children:[]},{value:"<code>requestsCapacity</code>",id:"requestscapacity",children:[]}],u={rightToc:c};function l(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"sending-requests-with-requestkey"},"Sending requests with ",Object(o.b)("inlineCode",{parentName:"h2"},"requestKey")),Object(o.b)("p",null,"Let's bring back ",Object(o.b)("strong",{parentName:"p"},"batch requests")," action from the previous part of the tutorial:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const fetchBook = ids => ({\n  type: FETCH_BOOK,\n  request: ids.map(id => ({ url: `/books/${id}` }),\n});\n")),Object(o.b)("p",null,"This is a good way to handle a case, in which you must fetch multiple details of\nsome objects at the same time. However, what if you need to fetch new instances gradually?\nFor instance, what if you need to fetch books with ",Object(o.b)("inlineCode",{parentName:"p"},"ids: ['1', '2']"),", but later you\nwould like to fetch ",Object(o.b)("inlineCode",{parentName:"p"},"3")," but without removing ",Object(o.b)("inlineCode",{parentName:"p"},"1")," and ",Object(o.b)("inlineCode",{parentName:"p"},"2"),"? Dispatching ",Object(o.b)("inlineCode",{parentName:"p"},"ids: ['3']"),"\nwould just erase books ",Object(o.b)("inlineCode",{parentName:"p"},"1")," and ",Object(o.b)("inlineCode",{parentName:"p"},"2"),". On the other hand, using ",Object(o.b)("inlineCode",{parentName:"p"},"ids: ['1', '2', '3']"),"\nwould not be very optimal, because you would refetch books ",Object(o.b)("inlineCode",{parentName:"p"},"1")," and ",Object(o.b)("inlineCode",{parentName:"p"},"2")," which you\nalready had."),Object(o.b)("p",null,"To tackle this situation, you can use ",Object(o.b)("inlineCode",{parentName:"p"},"meta.requestKey")," option:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const fetchBook = id => ({\n  type: FETCH_BOOK,\n  request: {\n    url: `/books/${id}`,\n  },\n  meta: {\n    requestKey: id, // it should be string\n  },\n});\n")),Object(o.b)("p",null,"So what ",Object(o.b)("inlineCode",{parentName:"p"},"requestKey")," does? Well, it tells ",Object(o.b)("inlineCode",{parentName:"p"},"requestsReducer")," to store ",Object(o.b)("inlineCode",{parentName:"p"},"FETCH_BOOK"),"\nqueries per each ",Object(o.b)("inlineCode",{parentName:"p"},"requestKey")," individually. So if you do:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"store.dispatch(fetchBook('1'));\n// later\nstore.dispatch(fetchBook('2'));\n")),Object(o.b)("p",null,"then the second request won't erase book ",Object(o.b)("inlineCode",{parentName:"p"},"1")," anymore. Additionally, doing:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"store.dispatch(fetchBook('1'));\nstore.dispatch(fetchBook('2'));\n")),Object(o.b)("p",null,"won't cause pending request for book ",Object(o.b)("inlineCode",{parentName:"p"},"1")," to be aborted, because now they are treated and stored\nseparately. However, dispatching multiple requests with the same ",Object(o.b)("inlineCode",{parentName:"p"},"requestKey")," at\nthe same time would still abort previous pending requests like described in abort part of the tutorial."),Object(o.b)("h2",{id:"selectors-with-requestkey"},"Selectors with ",Object(o.b)("inlineCode",{parentName:"h2"},"requestKey")),Object(o.b)("p",null,"When using ",Object(o.b)("inlineCode",{parentName:"p"},"requestKey"),", you need to remember to pass a matching ",Object(o.b)("inlineCode",{parentName:"p"},"requestKey"),"\nto selectors, for example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"import { getQuery } from '@redux-requests/core';\n\nconst { data, error, loading } = getQuery(\n  state,\n  { type: FETCH_BOOK, requestKey: '1' },\n);\n")),Object(o.b)("p",null,"Otherwise ",Object(o.b)("inlineCode",{parentName:"p"},"getQuery")," would just return ",Object(o.b)("inlineCode",{parentName:"p"},"{ data: null, loading: false, error: null}"),",\nbecause it wouldn't know which query to retrieve."),Object(o.b)("p",null,"The same applies to ",Object(o.b)("inlineCode",{parentName:"p"},"getMutation"),"."),Object(o.b)("h2",{id:"updating-data-of-queries-with-requestkey"},"Updating data of queries with ",Object(o.b)("inlineCode",{parentName:"h2"},"requestKey")),Object(o.b)("p",null,"Let's write a simple mutation to update book:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const updateBook = (id, title) => ({\n  type: UPDATE_BOOK,\n  request: {\n    url: `/books/${id}`,\n    method: 'post',\n    data: { title },\n  },\n  meta: {\n    mutations: {\n      [FETCH_BOOK]: (data, mutationData) => mutationData,\n    },\n  },\n});\n")),Object(o.b)("p",null,"If you try it, you will quickly find out that for some reason query data is not updated\nproperly. This is due to the same reason like in selectors, you need to pass a mathing\n",Object(o.b)("inlineCode",{parentName:"p"},"requestKey")," in ",Object(o.b)("inlineCode",{parentName:"p"},"mutations"),", like:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const updateBook = (id, title) => ({\n  type: UPDATE_BOOK,\n  request: {\n    url: `/books/${id}`,\n    method: 'post',\n    data: { title },\n  },\n  meta: {\n    mutations: {\n      [FETCH_BOOK + id]: (data, mutationData) => mutationData,\n    },\n  },\n});\n")),Object(o.b)("p",null,"So, all you need to do is add the matching ",Object(o.b)("inlineCode",{parentName:"p"},"requestKey")," to query type."),Object(o.b)("h2",{id:"mutations-with-requestkey"},"Mutations with ",Object(o.b)("inlineCode",{parentName:"h2"},"requestKey")),Object(o.b)("p",null,"Interestingly, not only queries can have ",Object(o.b)("inlineCode",{parentName:"p"},"requestKey"),". It can be useful to use it\nfor mutations too, for example if you wanted to show multiple loading spinners\nor errors at the same time:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const updateBook = (id, title) => ({\n  type: UPDATE_BOOK,\n  request: {\n    url: `/books/${id}`,\n    method: 'post',\n    data: { title },\n  },\n  meta: {\n    requestKey: id,\n    mutations: {\n      [FETCH_BOOK + id]: (data, mutationData) => mutationData,\n    },\n  },\n});\n")),Object(o.b)("h2",{id:"abortactions-and-resetactions-with-requestkey"},Object(o.b)("inlineCode",{parentName:"h2"},"abortActions")," and ",Object(o.b)("inlineCode",{parentName:"h2"},"resetActions")," with ",Object(o.b)("inlineCode",{parentName:"h2"},"requestKey")),Object(o.b)("p",null,"To use ",Object(o.b)("inlineCode",{parentName:"p"},"abortActions")," and ",Object(o.b)("inlineCode",{parentName:"p"},"resetActions")," with ",Object(o.b)("inlineCode",{parentName:"p"},"requestKey"),", you must pass an object\nwith ",Object(o.b)("inlineCode",{parentName:"p"},"requestType")," and ",Object(o.b)("inlineCode",{parentName:"p"},"requestKey")," instead of ",Object(o.b)("inlineCode",{parentName:"p"},"string"),", for example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"dispatch(abortRequests({ requestType: FETCH_BOOK, requestKey: '1' }]));\n")),Object(o.b)("h2",{id:"requestscapacity"},Object(o.b)("inlineCode",{parentName:"h2"},"requestsCapacity")),Object(o.b)("p",null,"You might think about ",Object(o.b)("inlineCode",{parentName:"p"},"requestKey")," concept - that's cool, but what about garbage collection\nand memory pollution? That's where ",Object(o.b)("inlineCode",{parentName:"p"},"meta.requestsCapacity")," comes in:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const fetchBook = id => ({\n  type: FETCH_BOOK,\n  request: {\n    url: `/books/${id}`,\n  },\n  meta: {\n    requestKey: id, // it should be string\n    requestsCapacity: 3,\n  },\n});\n")),Object(o.b)("p",null,"If not provided, your reducers will grow and grow, keeping requests with all used ",Object(o.b)("inlineCode",{parentName:"p"},"requestKey"),"s.\nHowever, in some cases number of stored requests could exceed thousands! To avoid that,\nyou could use ",Object(o.b)("inlineCode",{parentName:"p"},"meta.requestsCapacity"),", which automatically manages requests with the same\ntype but different keys according to FIFO (first in first out) rule. For instance,\npassing ",Object(o.b)("inlineCode",{parentName:"p"},"requestsCapacity: 3")," would allow only 3 requests to be stored at the same time.\nFor 4th request, the 1st one would be automatically removed."))}l.isMDXComponent=!0},149:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=r.a.createContext({}),l=function(e){var t=r.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s({},t,{},e)),n},d=function(e){var t=l(e.components);return r.a.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=l(n),b=a,m=d["".concat(i,".").concat(b)]||d[b]||p[b]||o;return n?r.a.createElement(m,s({ref:t},u,{components:n})):r.a.createElement(m,s({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=b;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);