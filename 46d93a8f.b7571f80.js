(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{122:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return a})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return l}));var r=n(1),o=n(6),i=(n(0),n(158)),s={title:"Server side rendering",description:"SSR guide for redux-requests - declarative AJAX requests and automatic network state management for single-page applications"},a={id:"guides/server-side-rendering",title:"Server side rendering",description:"SSR guide for redux-requests - declarative AJAX requests and automatic network state management for single-page applications",source:"@site/docs/guides/server-side-rendering.md",permalink:"/docs/guides/server-side-rendering",editUrl:"https://github.com/klis87/redux-requests/edit/master/docusaurus/docs/guides/server-side-rendering.md",lastUpdatedBy:"Konrad",lastUpdatedAt:1610499904,sidebar:"docs",previous:{title:"Selectors",permalink:"/docs/guides/selectors"},next:{title:"Usage with redux-saga",permalink:"/docs/guides/usage-with-redux-saga"}},c=[{value:"What is server side rendering?",id:"what-is-server-side-rendering",children:[]},{value:"Two SSR strategies",id:"two-ssr-strategies",children:[]},{value:"Pure Redux",id:"pure-redux",children:[{value:"Basic setup",id:"basic-setup",children:[]},{value:"How does it work?",id:"how-does-it-work",children:[]}]},{value:"React suspense",id:"react-suspense",children:[{value:"Basic setup on the server",id:"basic-setup-on-the-server",children:[]},{value:"Basic setup on the client",id:"basic-setup-on-the-client",children:[]}]},{value:"Hybrid approach",id:"hybrid-approach",children:[]}],u={rightToc:c};function l(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"what-is-server-side-rendering"},"What is server side rendering?"),Object(i.b)("p",null,"Like its name suggests, it is just a way to render you app on the server side. Why\nwould you do that for single page application? There are many reasons, like SEO,\nimproving performance in some cases, static rendering like in Gatsby and probably many\nothers."),Object(i.b)("p",null,"Anyway server side rendering is a very complex topic and there are many ways how to go about it.\nMany people use the strategy around React components, for instance they attach static methods to components which\nmake requests and return promises with responses, then they wrap them in ",Object(i.b)("inlineCode",{parentName:"p"},"Promise.all"),". I don't recommend this strategy\nwhen using Redux, because this requires additional code and potentially double rendering on server, but if you really want\nto do it, it is possible as dispatched request actions return promise resolved with response."),Object(i.b)("p",null,"However, this guide won't be for introducing server side rendering, it will show alternative\nstrategies for SSR with the help of this library. You don't need to use any of them,\nbut you might want to check them out as they could potentially simplify your SSR apps."),Object(i.b)("h2",{id:"two-ssr-strategies"},"Two SSR strategies"),Object(i.b)("p",null,"There two recommended strategies for SSR with ",Object(i.b)("inlineCode",{parentName:"p"},"redux-requests"),":"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"pure Redux strategy, in which you need to dispatch all request actions on the Redux level, then you await promise which will resolve\nonce all requests are finished, after which you are ready to render on server side with any framework of your choosing, be it React or anything else"),Object(i.b)("li",{parentName:"ol"},"React suspense strategy, which assumes that you dispatch request actions from React components")),Object(i.b)("p",null,"The choice depends on your taste and whether you dispatch actions from Redux or from React. In theory, it should be possible\nto use a hybrid/combination of those two methods (and dispatching request actions both from Redux and React level)!"),Object(i.b)("h2",{id:"pure-redux"},"Pure Redux"),Object(i.b)("p",null,"Before we begin, be advised that this strategy requires to dispatch request actions on Redux level, at least those which have to be\nfired on application load. So for instance you cannot dispatch them inside React ",Object(i.b)("inlineCode",{parentName:"p"},"componentDidMount"),"\nor in ",Object(i.b)("inlineCode",{parentName:"p"},"useEffect"),". The obvious place to dispatch them is in the place you create store, like ",Object(i.b)("inlineCode",{parentName:"p"},"store.dispatch(fetchBooks())"),". However, what if your app has multiple routes, and each route has to send different requests?\nWell, you need to make Redux aware of current route. I recommend to use a router with first class support for\nRedux, namely ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/faceyspacey/redux-first-router"}),"redux-first-router"),".\nIf you use ",Object(i.b)("inlineCode",{parentName:"p"},"react-router")," though, it is fine too, you just need to integrate it with Redux with\n",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/supasate/connected-react-router"}),"connected-react-router")," or\n",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/salvoravida/redux-first-history"}),"redux-first-history"),". Then you\ncould listen to route change actions and dispatch proper request actions, for example\nfrom middleware, sagas, just whatever you use."),Object(i.b)("h3",{id:"basic-setup"},"Basic setup"),Object(i.b)("p",null,"On the server you need to pass ",Object(i.b)("inlineCode",{parentName:"p"},"ssr: 'server'")," to ",Object(i.b)("inlineCode",{parentName:"p"},"handleRequests")," when running on\nthe server (to resolve/reject ",Object(i.b)("inlineCode",{parentName:"p"},"requestsPromise")," in the right time) and ",Object(i.b)("inlineCode",{parentName:"p"},"ssr: 'client'"),"\non the client (not to repeat requests again on the client which we run on the server)\noption to ",Object(i.b)("inlineCode",{parentName:"p"},"handleRequests"),". Here you can see a possible implementation:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx"}),"import { createStore, applyMiddleware, combineReducers } from 'redux';\nimport axios from 'axios';\nimport { handleRequests } from '@redux-requests/core';\nimport { createDriver } from '@redux-requests/axios';\n\nimport { fetchBooks } from './actions';\n\nexport const configureStore = (initialState = undefined) => {\n  const ssr = !initialState; // if initialState is not passed, it means we run it on server\n\n  const {\n    requestsReducer,\n    requestsMiddleware,\n    requestsPromise,\n  } = handleRequests({\n    driver: createDriver(\n      axios.create({\n        baseURL: 'http://localhost:3000',\n      }),\n    ),\n    ssr: ssr ? 'server' : 'client',\n  });\n\n  const reducers = combineReducers({\n    requests: requestsReducer,\n  });\n\n  const store = createStore(\n    reducers,\n    initialState,\n    applyMiddleware(...requestsMiddleware),\n  );\n\n  store.dispatch(fetchBooks());\n  return { store, requestsPromise };\n};\n\n// on the server\nimport React from 'react';\nimport { renderToString } from 'react-dom/server';\nimport { Provider } from 'react-redux';\n\n// in an express/another server handler\nconst { store, requestsPromise } = configureStore();\n\nrequestsPromise\n  .then(() => {\n    const html = renderToString(\n      <Provider store={store}>\n        <App />\n      </Provider>,\n    );\n\n    res.render('index', {\n      html,\n      initialState: JSON.stringify(store.getState()),\n    });\n  })\n  .catch(e => {\n    console.log('error', e);\n    res.status(400).send('something went wrong');\n    // you can also render React too, like for 404 error\n  });\n")),Object(i.b)("p",null,"As you can see, compared to what you would normally do in SSR for redux app, you only need to\npass the extra ",Object(i.b)("inlineCode",{parentName:"p"},"ssr")," option to ",Object(i.b)("inlineCode",{parentName:"p"},"handleRequests")," and wait for ",Object(i.b)("inlineCode",{parentName:"p"},"requestsPromise")," to be resolved."),Object(i.b)("h3",{id:"how-does-it-work"},"How does it work?"),Object(i.b)("p",null,"But how does it work? The logic is based on an internal counter. Initially it is set to ",Object(i.b)("inlineCode",{parentName:"p"},"0")," and is\nincreased by ",Object(i.b)("inlineCode",{parentName:"p"},"1")," after each request is initialized. Then, after each response it is decreased by ",Object(i.b)("inlineCode",{parentName:"p"},"1"),". So, initially after a first\nrequest it gets positive and after all requests are finished, its value is again set back to ",Object(i.b)("inlineCode",{parentName:"p"},"0"),". And this is the moment\nwhich means that all requests are finished and ",Object(i.b)("inlineCode",{parentName:"p"},"requestsPromise")," is resolved (with all success actions)."),Object(i.b)("p",null,"In case of any request error, ",Object(i.b)("inlineCode",{parentName:"p"},"requestsPromise")," will be rejected with object ",Object(i.b)("inlineCode",{parentName:"p"},"{ errorActions: [], successActions: [] }"),"."),Object(i.b)("p",null,"There is also more complex case. Imagine you have a request ",Object(i.b)("inlineCode",{parentName:"p"},"x"),", after which you would like to dispatch\nanother ",Object(i.b)("inlineCode",{parentName:"p"},"y"),". You cannot do it immediately because ",Object(i.b)("inlineCode",{parentName:"p"},"y")," requires some information from ",Object(i.b)("inlineCode",{parentName:"p"},"x")," response.\nAbove algorythm would not wait for ",Object(i.b)("inlineCode",{parentName:"p"},"y")," to be finished, because on ",Object(i.b)("inlineCode",{parentName:"p"},"x")," response counter would be\nalready reset to ",Object(i.b)("inlineCode",{parentName:"p"},"0"),". There are two ",Object(i.b)("inlineCode",{parentName:"p"},"action.meta")," attributes to help here:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"dependentRequestsNumber")," - a positive integer, a number of requests which will be fired after this one,\nin above example we would put ",Object(i.b)("inlineCode",{parentName:"li"},"dependentRequestsNumber: 1")," to ",Object(i.b)("inlineCode",{parentName:"li"},"x")," action, because only ",Object(i.b)("inlineCode",{parentName:"li"},"y")," depends on ",Object(i.b)("inlineCode",{parentName:"li"},"x")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"isDependentRequest")," - mark a request as ",Object(i.b)("inlineCode",{parentName:"li"},"isDependentRequest: true")," when it depends on another request,\nin our example we would put ",Object(i.b)("inlineCode",{parentName:"li"},"isDependentRequest: true")," to ",Object(i.b)("inlineCode",{parentName:"li"},"y"),", because it depends on ",Object(i.b)("inlineCode",{parentName:"li"},"x"))),Object(i.b)("p",null,"You could even have a more complicated situation, in which you would need to dispatch ",Object(i.b)("inlineCode",{parentName:"p"},"z")," after ",Object(i.b)("inlineCode",{parentName:"p"},"y"),". Then\nyou would also add ",Object(i.b)("inlineCode",{parentName:"p"},"dependentRequestsNumber: 1")," to ",Object(i.b)("inlineCode",{parentName:"p"},"y")," and ",Object(i.b)("inlineCode",{parentName:"p"},"isDependentRequest: true")," to ",Object(i.b)("inlineCode",{parentName:"p"},"z"),". Yes, a request\ncan have both of those attibutes at the same time! Anyway, how does it work? Easy, just a request with\n",Object(i.b)("inlineCode",{parentName:"p"},"dependentRequestsNumber: 2")," would increase counter by ",Object(i.b)("inlineCode",{parentName:"p"},"3")," on request and decrease by ",Object(i.b)("inlineCode",{parentName:"p"},"1")," on response,\nwhile an action with ",Object(i.b)("inlineCode",{parentName:"p"},"isDependentRequest: true")," would increase counter on request by ",Object(i.b)("inlineCode",{parentName:"p"},"1")," as usual but decrease\nit on response by ",Object(i.b)("inlineCode",{parentName:"p"},"2"),". So, the counter will be reset to ",Object(i.b)("inlineCode",{parentName:"p"},"0")," after all requests are finished, also dependent ones."),Object(i.b)("h2",{id:"react-suspense"},"React suspense"),Object(i.b)("p",null,"This strategy requires using suspense on the server side. Suspense is not officially supported yet on server side,\nbut it is already possible thanks to ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/overlookmotel/react-async-ssr"}),"react-async-ssr"),". Using it\nis only temporary, hopefully soon we will have this built inside React core. I tested it and it works surprisingly well,\nthe only downside is that it officially supports only React 16.6.0-16.9.x. It is not a big issue though as 16.10+ doesn't\nreally bring any new features."),Object(i.b)("p",null,"Anyway, this strategy assumes that you dispatch requests from React components (namely from ",Object(i.b)("inlineCode",{parentName:"p"},"useQuery")," hooks)."),Object(i.b)("h3",{id:"basic-setup-on-the-server"},"Basic setup on the server"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx"}),"import React from 'react';\nimport { RequestsProvider } from '@redux-requests/react';\nimport { createDriver } from '@redux-requests/axios';\nimport { renderToStringAsync } from 'react-async-ssr';\nimport axios from 'axios';\n\n// in an express/another server handler\n\nlet store;\n\nconst html = await renderToStringAsync(\n  <RequestsProvider\n    requestsConfig={{\n      driver: createDriver(\n        axios.create({\n          baseURL: 'http://localhost:3000',\n        }),\n      ),\n      ssr: 'server',\n      disableRequestsPromise: true, // necessary to avoid unhandled promise rejection error\n    }}\n    getStore={requestsStore => {\n      store = requestsStore;\n    }}\n    suspenseSsr\n  >\n    <App />\n  </RequestsProvider>,\n);\n\nres.render('index', {\n  html,\n  initialState: JSON.stringify(store.getState()),\n});\n")),Object(i.b)("p",null,"That's all there is to it, ",Object(i.b)("inlineCode",{parentName:"p"},"App")," component can be universal, written like there was no SSR involved at all!\nThe only thing you need to remember is to wrap your components in ",Object(i.b)("inlineCode",{parentName:"p"},"App")," by ",Object(i.b)("inlineCode",{parentName:"p"},"Suspense"),", for example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx"}),"import React, { Suspense } from 'react';\n\nconst App = () => {\n  return (\n    <Suspense fallback=\"Loading\">\n      <AppComponents>\n    </Suspense>\n  );\n};\n")),Object(i.b)("p",null,"This is needed because ",Object(i.b)("inlineCode",{parentName:"p"},"suspenseSsr")," option forces suspense on the server for all ",Object(i.b)("inlineCode",{parentName:"p"},"useQuery")," hooks (no matter what ",Object(i.b)("inlineCode",{parentName:"p"},"suspense")," option you choose).\nAlso note, that it doesn't hurt that ",Object(i.b)("inlineCode",{parentName:"p"},"Suspense")," component would be used on the client side as well - if you don't use suspense on\nthe client, it will just never be triggered."),Object(i.b)("h3",{id:"basic-setup-on-the-client"},"Basic setup on the client"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx"}),"import React from 'react';\nimport axios from 'axios';\nimport { hydrate } from 'react-dom';\nimport { RequestsProvider } from '@redux-requests/react';\nimport { createDriver } from '@redux-requests/axios';\n\nhydrate(\n  <RequestsProvider\n    requestsConfig={{\n      driver: createDriver(\n        axios.create({\n          baseURL: 'http://localhost:3000',\n        }),\n      ),\n      ssr: 'client',\n    }}\n    initialState={window.__INITIAL_STATE__}\n  >\n    <App />\n  </RequestsProvider>,\n  document.getElementById('root'),\n);\n")),Object(i.b)("p",null,"Simple, isn't it? You just need to use ",Object(i.b)("inlineCode",{parentName:"p"},"ssr: 'client'")," and pass ",Object(i.b)("inlineCode",{parentName:"p"},"initialState")," and you are good to go!"),Object(i.b)("h2",{id:"hybrid-approach"},"Hybrid approach"),Object(i.b)("p",null,"In theory you could use combination of those two methods! You could:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"create your store and run some requests on Redux level"),Object(i.b)("li",{parentName:"ol"},"await ",Object(i.b)("inlineCode",{parentName:"li"},"requestsPromise")),Object(i.b)("li",{parentName:"ol"},"render asynchronously React with suspense, you would pass your already created store to ",Object(i.b)("inlineCode",{parentName:"li"},"RequestsProvider")),Object(i.b)("li",{parentName:"ol"},"additional requests would be fired on React level")),Object(i.b)("p",null,"This should work in theory, in has not been tested in practice though, as I usually dispatch actions either from Redux or React,\ndepending on the app. If you like mixing though, you could definitely try it!"))}l.isMDXComponent=!0},158:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return h}));var r=n(0),o=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=o.a.createContext({}),l=function(e){var t=o.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):a({},t,{},e)),n},d=function(e){var t=l(e.components);return o.a.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},b=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=l(n),b=r,h=d["".concat(s,".").concat(b)]||d[b]||p[b]||i;return n?o.a.createElement(h,a({ref:t},u,{components:n})):o.a.createElement(h,a({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=b;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a.mdxType="string"==typeof e?e:r,s[1]=a;for(var u=2;u<i;u++)s[u]=n[u];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);